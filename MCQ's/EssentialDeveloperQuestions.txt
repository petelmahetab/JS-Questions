Essential Developer Interview Questions (2025)
These 25 output-based questions test critical knowledge for developers in intermediate networking, deployments (CI/CD, AWS, Azure), and production-level design patterns. Each question includes a code snippet or scenario, four answer options, the correct answer, and an explanation to prepare you for technical interviews.

1. What is the output of the following React code with a network fetch?
import React, { useState, useEffect } from 'react';

function App() {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetch('https://api.example.com/data')
      .then((res) => res.json())
      .then((result) => {
        setData(result);
        console.log(result.value);
      });
  }, []);
  return <div>{data ? data.value : 'Loading'}</div>;
}

A) Loading, then fetched dataB) undefinedC) TypeErrorD) null
Answer: A) Loading, then fetched dataExplanation: The useEffect runs once, fetching data and updating data. The component renders 'Loading' until the data is set, then displays result.value. The console logs the fetched value. This tests async fetching, common in MERN apps with REST APIs.

2. What happens when this Express route handles a request?
const express = require('express');
const app = express();

app.get('/api/user', (req, res) => {
  console.log('Request received');
  res.json({ user: 'John' });
});

app.listen(3000, () => console.log('Server running'));

A) Server running, Request received (on request)B) Request received, Server runningC) TypeErrorD) No output
Answer: A) Server running, Request received (on request)Explanation: The server starts, logging 'Server running'. Each /api/user request logs 'Request received' and returns { user: 'John' }. This tests basic Express routing, a key MERN backend skill.

3. What is logged in this Node.js TCP connection?
const net = require('net');

const server = net.createServer((socket) => {
  console.log('Client connected');
  socket.on('data', (data) => console.log(data.toString()));
});

server.listen(8080, () => console.log('TCP server started'));

A) TCP server started, Client connected (on connection)B) Client connected, TCP server startedC) TypeErrorD) No output
Answer: A) TCP server started, Client connected (on connection)Explanation: The TCP server starts, logging 'TCP server started'. On client connection, it logs 'Client connected' and logs any data sent. This tests intermediate networking with Node.js TCP servers.

4. What is the outcome of this DNS resolution in Node.js?
const dns = require('dns');

dns.resolve('example.com', (err, addresses) => {
  if (err) {
    console.log('Error:', err.message);
    return;
  }
  console.log(addresses);
});

A) Array of IP addresses (e.g., ['93.184.216.34'])B) Error: queryA ENOTFOUND example.comC) undefinedD) TypeError
Answer: A) Array of IP addresses (e.g., ['93.184.216.34'])Explanation: The dns.resolve queries the DNS for example.com, returning an array of IP addresses if successful. Errors occur only for invalid domains. This tests DNS resolution, a core networking concept.

5. What is logged in this React app with CORS?
import React, { useEffect } from 'react';

function App() {
  useEffect(() => {
    fetch('http://localhost:3000/api/data')
      .then((res) => res.json())
      .catch((err) => console.log('Error:', err.message));
  }, []);
  return <div>Test</div>;
}

A) Error: Network Error (if CORS not configured)B) Fetched dataC) No outputD) TypeError
Answer: A) Error: Network Error (if CORS not configured)Explanation: Without CORS configured on the backend, the cross-origin request fails, logging a Network Error. This aligns with your past CORS issues (March 8, 2025) and tests networking in MERN apps.

6. What is the output of this Express CORS setup?
const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors({ origin: 'http://localhost:3001' }));

app.get('/api/data', (req, res) => {
  console.log('Data requested');
  res.json({ value: 'Test' });
});

app.listen(3000, () => console.log('Server running'));

A) Server running, Data requested (on valid request)B) Error: CORS policy blockedC) TypeErrorD) No output
Answer: A) Server running, Data requested (on valid request)Explanation: The server starts, logging 'Server running'. Requests from http://localhost:3001 are allowed by CORS, logging 'Data requested' and returning data. This tests CORS configuration, a deployment essential.

7. What is logged in this CI/CD environment variable setup?
import React, { useEffect, useState } from 'react';

function App() {
  const [env, setEnv] = useState(null);
  useEffect(() => {
    const envVar = process.env.REACT_APP_ENV;
    setEnv(envVar);
    console.log(envVar);
  }, []);
  return <div>{env || 'No env'}</div>;
}

A) production (in AWS Amplify CI/CD)B) undefinedC) TypeErrorD) No env
Answer: A) production (in AWS Amplify CI/CD)Explanation: In an AWS Amplify CI/CD pipeline, REACT_APP_ENV is set to 'production' in production builds, logged and displayed. This tests environment variables in cloud deployments, as seen in your Vercel queries (March 8, 2025).

8. What is the outcome of this Azure API fetch?
import React, { useState, useEffect } from 'react';

function App() {
  const [config, setConfig] = useState(null);
  useEffect(() => {
    fetch('/api/config')
      .then((res) => res.json())
      .then((data) => {
        setConfig(data);
        console.log(data.env);
      });
  }, []);
  return <div>{config ? config.env : 'Loading'}</div>;
}

A) production (in Azure Static Web Apps)B) undefinedC) TypeErrorD) Loading
Answer: A) production (in Azure Static Web Apps)Explanation: In Azure Static Web Apps, a CI/CD pipeline (e.g., GitHub Actions) sets data.env to 'production'. The fetch logs and displays this value. This tests cloud API integration, a key deployment skill.

9. What is logged in this Singleton pattern implementation?
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    Singleton.instance = this;
    this.value = 'Singleton';
  }
}

const obj1 = new Singleton();
const obj2 = new Singleton();
console.log(obj1 === obj2, obj1.value);

A) true, SingletonB) false, SingletonC) TypeErrorD) undefined
Answer: A) true, SingletonExplanation: The Singleton pattern ensures one instance. obj1 and obj2 reference the same instance, so obj1 === obj2 is true, and obj1.value is 'Singleton'. This tests a production-level design pattern.

10. What is the output of this Factory pattern?
class UserFactory {
  static createUser(type) {
    if (type === 'admin') return { role: 'Admin' };
    return { role: 'User' };
  }
}

const user = UserFactory.createUser('admin');
console.log(user.role);

A) AdminB) UserC) TypeErrorD) undefined
Answer: A) AdminExplanation: The Factory pattern creates objects based on conditions. createUser('admin') returns { role: 'Admin' }, logged as 'Admin'. This tests a design pattern for scalable object creation.

11. What is logged in this Circuit Breaker pattern?
class CircuitBreaker {
  constructor() {
    this.state = 'CLOSED';
  }
  request() {
    if (this.state === 'OPEN') {
      console.log('Request blocked');
      return;
    }
    console.log('Request processed');
  }
  trip() {
    this.state = 'OPEN';
  }
}

const cb = new CircuitBreaker();
cb.request();
cb.trip();
cb.request();

A) Request processed, Request blockedB) Request blocked, Request processedC) TypeErrorD) No output
Answer: A) Request processed, Request blockedExplanation: The Circuit Breaker pattern prevents repeated failed requests. The first request() logs 'Request processed' (CLOSED state). After trip(), the state is OPEN, so the second request() logs 'Request blocked'. This tests a production resilience pattern.

12. What is the output of this load balancer simulation?
function loadBalancer(servers, requestId) {
  const index = requestId % servers.length;
  console.log(`Routing to ${servers[index]}`);
  return servers[index];
}

loadBalancer(['server1', 'server2', 'server3'], 4);

A) Routing to server2B) Routing to server1C) TypeErrorD) undefined
Answer: A) Routing to server2Explanation: The load balancer uses modulo to distribute requests. 4 % 3 = 1, so it routes to servers[1] ('server2'). This tests intermediate networking for load distribution.

13. What is logged in this WebSocket connection?
const WebSocket = require('ws');

const server = new WebSocket.Server({ port: 8080 });
server.on('connection', (ws) => {
  console.log('Client connected');
  ws.on('message', (msg) => console.log(`Received: ${msg}`));
});

console.log('WebSocket server started');

A) WebSocket server started, Client connected (on connection)B) Client connected, WebSocket server startedC) TypeErrorD) No output
Answer: A) WebSocket server started, Client connected (on connection)Explanation: The WebSocket server starts, logging 'WebSocket server started'. On client connection, it logs 'Client connected' and handles messages. This tests WebSocket networking, relevant to your Socket.IO queries (March 21, 2025).

14. What is the outcome of this AWS Lambda handler?
exports.handler = async (event) => {
  console.log('Lambda invoked');
  return {
    statusCode: 200,
    body: JSON.stringify({ message: 'Success' }),
  };
};

A) Lambda invoked, { statusCode: 200, body: "{"message":"Success"}" }B) TypeErrorC) undefinedD) No output
Answer: A) Lambda invoked, { statusCode: 200, body: "{"message":"Success"}" }Explanation: The AWS Lambda handler logs 'Lambda invoked' and returns a response object. This tests serverless deployment, a modern cloud pattern in AWS.

15. What is logged in this Azure Function?
module.exports = async function (context, req) {
  context.log('Function triggered');
  return {
    status: 200,
    body: { message: 'Hello Azure' },
  };
};

A) Function triggered, { status: 200, body: { message: 'Hello Azure' } }B) TypeErrorC) undefinedD) No output
Answer: A) Function triggered, { status: 200, body: { message: 'Hello Azure' } }Explanation: The Azure Function logs 'Function triggered' and returns a response. This tests serverless deployment in Azure, a key cloud skill.

16. What is the output of this Observer pattern?
class Subject {
  constructor() {
    this.observers = [];
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  notify(data) {
    this.observers.forEach((obs) => obs.update(data));
  }
}

class Observer {
  update(data) {
    console.log(`Update: ${data}`);
  }
}

const subject = new Subject();
const obs = new Observer();
subject.addObserver(obs);
subject.notify('Event');

A) Update: EventB) TypeErrorC) undefinedD) No output
Answer: